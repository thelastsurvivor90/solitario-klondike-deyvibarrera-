\documentclass[12pt,letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\hypersetup{
	hidelinks
}

\usepackage{fancyhdr}

\geometry{margin=1in}

% Configuracion de listings para codigo Python
\lstset{
	language=Python,
	basicstyle=\ttfamily\small,
	keywordstyle=\color{blue}\bfseries,
	commentstyle=\color{gray}\itshape,
	stringstyle=\color{red},
	numbers=left,
	numberstyle=\tiny\color{gray},
	stepnumber=1,
	numbersep=5pt,
	backgroundcolor=\color{white},
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	frame=single,
	tabsize=4,
	captionpos=b,
	breaklines=true,
	breakatwhitespace=false,
	xleftmargin=2em,
	framexleftmargin=1.5em
}

% Encabezados
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Simulacion Solitario Klondike}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

\title{\textbf{Simulacion Grafica de Solitario Klondike} \\ 
	\large Implementacion con Python y Tkinter 

	EstadÃ­stica Descriptiva y Probabilidad 2025-II
	}
\author{Deyvi Samuel Barrera Rodriguez}
\date{\today}

\begin{document}
	
	\maketitle
	\thispagestyle{empty}
	\newpage
	
	\tableofcontents
	\newpage
	
	\section{Introduccion}
	
	El presente documento describe la implementacion de una simulacion grafica del juego de cartas \textbf{Solitario Klondike}, conocido popularmente como el solitario clasico de Windows. El proyecto fue desarrollado utilizando Python como lenguaje de programacion y Tkinter como framework para la interfaz grafica.
	
	\subsection{Objetivos del Proyecto}
	
	\begin{itemize}
		\item Implementar un juego de mesa completo con interfaz grafica interactiva
		\item Aplicar principios de Programacion Orientada a Objetos
		\item Demostrar el manejo de estructuras de datos complejas
		\item Crear una experiencia de usuario fluida con eventos y animaciones
	\end{itemize}
	
	\subsection{Seleccion del Juego}
	
	Se eligio el Solitario Klondike por las siguientes razones:
	
	\begin{enumerate}
		\item Es un juego ampliamente conocido y reconocible
		\item Presenta desafios interesantes en terminos de logica de programacion
		\item Permite demostrar manejo de multiples estructuras de datos
		\item Ofrece oportunidades para implementar drag and drop y animaciones
	\end{enumerate}
	
	\section{Marco Teorico}
	
	\subsection{Programacion Orientada a Objetos}
	
	La Programacion Orientada a Objetos (POO) es un paradigma de programacion que organiza el codigo en objetos que contienen datos (atributos) y comportamientos (metodos). Los pilares fundamentales de la POO son:
	
	\begin{description}
		\item[Encapsulamiento:] Agrupa datos y metodos relacionados, ocultando los detalles de implementacion.
		\item[Herencia:] Permite crear nuevas clases basadas en clases existentes.
		\item[Polimorfismo:] Capacidad de objetos de diferentes clases de responder al mismo mensaje.
		\item[Abstraccion:] Simplifica sistemas complejos modelando clases apropiadas al problema.
	\end{description}
	
	\subsection{Tkinter}
	
	Tkinter es la biblioteca estandar de Python para crear interfaces graficas de usuario (GUI). Caracteristicas principales:
	
	\begin{itemize}
		\item Incluida por defecto en la instalacion de Python
		\item Multiplataforma (Windows, macOS, Linux)
		\item Basada en el toolkit Tk
		\item Proporciona widgets como botones, etiquetas, canvas, etc.
	\end{itemize}
	
	\subsection{Reglas del Solitario Klondike}
	
	El Solitario Klondike se juega con una baraja estandar de 52 cartas:
	
	\begin{itemize}
		\item \textbf{Objetivo:} Construir cuatro fundaciones (pilas base) ordenadas del As al Rey, una por cada palo.
		\item \textbf{Tableau:} Siete columnas donde se distribuyen las cartas al inicio.
		\item \textbf{Mazo:} Cartas restantes que pueden ser robadas.
		\item \textbf{Waste:} Pila de descarte para cartas robadas del mazo.
	\end{itemize}
	
	\textbf{Movimientos permitidos:}
	\begin{enumerate}
		\item Cartas en el tableau deben alternarse en color (rojo-negro) y decrecer en valor
		\item Solo los Reyes pueden colocarse en espacios vacios del tableau
		\item Las fundaciones deben comenzar con As y construirse en orden ascendente del mismo palo
	\end{enumerate}
	
	\section{Diseno e Implementacion}
	
	\subsection{Arquitectura del Sistema}
	
	El sistema esta compuesto por tres clases principales que interactuan entre si:
	
	\begin{itemize}
		\item \textbf{Card}: Representa una carta individual
		\item \textbf{CardWidget}: Visualizacion de carta en canvas
		\item \textbf{SolitaireGame}: Logica principal del juego
	\end{itemize}
	
	\subsection{Clase Card}
	
	La clase \texttt{Card} representa una carta individual del juego:
	
	\begin{lstlisting}[caption={Definicion de la clase Card}]
		@dataclass
		class Card:
		suit: str      # Palo: picas, corazones, diamantes, treboles
		rank: str      # Rango: A, 2-10, J, Q, K
		face_up: bool = False  # Estado de la carta
		
		def get_value(self) -> int:
		return RANKS.index(self.rank) + 1
		
		def get_color(self) -> str:
		return COLORS[self.suit]
	\end{lstlisting}
	
	\textbf{Justificacion del diseno:}
	\begin{itemize}
		\item Uso de dataclass para reducir codigo
		\item Metodos auxiliares para comparaciones logicas
		\item Separacion clara entre datos y comportamiento
	\end{itemize}
	
	\subsection{Clase CardWidget}
	
	Responsable de la representacion visual de cada carta:
	
	\begin{lstlisting}[caption={Metodo draw de CardWidget}]
		def draw(self):
		if self.card.face_up:
		fill = 'white'
		color = self.card.get_color()
		# Dibujar simbolos del palo
		else:
		fill = '#2E5090'
		# Dibujar patron de carta boca abajo
	\end{lstlisting}
	
	\textbf{Caracteristicas importantes:}
	\begin{itemize}
		\item Separacion entre modelo (Card) y vista (CardWidget)
		\item Metodo move\_to() con soporte para animaciones
		\item Gestion eficiente de elementos graficos en canvas
	\end{itemize}
	
	\subsection{Clase SolitaireGame}
	
	Clase principal que coordina toda la logica del juego:
	
	\subsubsection{Estructuras de Datos}
	
	\begin{lstlisting}[caption={Estructuras de datos principales}]
		self.deck: List[Card] = []
		self.waste: List[Card] = []
		self.foundations: List[List[Card]] = [[] for _ in range(4)]
		self.tableau: List[List[Card]] = [[] for _ in range(7)]
	\end{lstlisting}
	
	Cada estructura tiene un proposito especifico:
	
	\begin{table}[h]
		\centering
		\begin{tabular}{|l|p{8cm}|}
			\hline
			\textbf{Estructura} & \textbf{Proposito} \\
			\hline
			deck & Almacena cartas no robadas \\
			waste & Cartas robadas del mazo \\
			foundations & 4 pilas objetivo (una por palo) \\
			tableau & 7 columnas de juego \\
			\hline
		\end{tabular}
		\caption{Estructuras de datos del juego}
	\end{table}
	
	\subsubsection{Gestion de Eventos}
	
	El sistema implementa un sofisticado manejo de eventos mouse:
	
	\begin{lstlisting}[caption={Vinculacion de eventos}]
		self.canvas.bind('<Button-1>', self.on_click)
		self.canvas.bind('<B1-Motion>', self.on_drag)
		self.canvas.bind('<ButtonRelease-1>', self.on_release)
	\end{lstlisting}
	
	El flujo de eventos sigue este patron:
	
	\begin{enumerate}
		\item \textbf{Click}: Detecta que elemento fue clickeado
		\item \textbf{Drag}: Actualiza la posicion durante el arrastre
		\item \textbf{Release}: Valida y ejecuta el movimiento
	\end{enumerate}
	
	\subsection{Validacion de Movimientos}
	
	\subsubsection{Movimientos al Tableau}
	
	\begin{lstlisting}[caption={Validacion de movimiento al tableau}]
		def can_move_to_tableau(self, cards, pile_idx):
		pile = self.tableau[pile_idx]
		first_card = cards[0]
		
		if not pile:
		return first_card.rank == 'K'
		
		top_card = pile[-1]
		return (first_card.get_color() != top_card.get_color() and
		first_card.get_value() == top_card.get_value() - 1)
	\end{lstlisting}
	
	\textbf{Condiciones verificadas:}
	\begin{itemize}
		\item Pilas vacias solo aceptan Reyes
		\item Los colores deben alternar (rojo-negro)
		\item El valor debe ser exactamente uno menor
	\end{itemize}
	
	\subsubsection{Movimientos a Fundaciones}
	
	\begin{lstlisting}[caption={Validacion de movimiento a fundacion}]
		def can_move_to_foundation(self, card, foundation_idx):
		foundation = self.foundations[foundation_idx]
		
		if not foundation:
		return card.rank == 'A'
		
		top_card = foundation[-1]
		return (card.suit == top_card.suit and
		card.get_value() == top_card.get_value() + 1)
	\end{lstlisting}
	
	\textbf{Reglas implementadas:}
	\begin{itemize}
		\item Fundaciones vacias requieren As
		\item Mismo palo obligatorio
		\item Secuencia ascendente estricta
	\end{itemize}
	
	\section{Caracteristicas Avanzadas}
	
	\subsection{Sistema Drag and Drop}
	
	El sistema de arrastre utiliza una estructura de datos temporal:
	
	\begin{lstlisting}[caption={Estructura para drag and drop}]
		self.drag_data = {
			'cards': [],
			'source': None,
			'start_x': 0,
			'start_y': 0
		}
	\end{lstlisting}
	
	\subsection{Deteccion de Colisiones}
	
	Para determinar donde soltar las cartas:
	
	\begin{lstlisting}[caption={Deteccion de zona de soltado}]
		def on_release(self, event):
		x, y = event.x, event.y
		
		foundation_idx = self.is_click_on_foundation(x, y)
		if foundation_idx is not None:
		if self.can_move_to_foundation(...):
		self.move_to_foundation(foundation_idx)
		
		for i in range(7):
		if self.is_position_in_pile(x, y, i):
		if self.can_move_to_tableau(...):
		self.move_to_tableau(i)
	\end{lstlisting}
	
	\subsection{Animaciones}
	
	El metodo move\_to() incluye soporte para animacion:
	
	\begin{lstlisting}[caption={Animacion de movimiento}]
		def move_to(self, x, y, animate=False):
		if animate:
		steps = 10
		dx = (x - self.x) / steps
		dy = (y - self.y) / steps
		
		for _ in range(steps):
		self.x += dx
		self.y += dy
		self.draw()
		self.canvas.update()
		self.canvas.after(20)
	\end{lstlisting}
	
	\section{Analisis de Complejidad}
	
	\subsection{Complejidad Temporal}
	
	Operaciones principales y su complejidad:
	
	\begin{table}[h]
		\centering
		\begin{tabular}{|l|c|l|}
			\hline
			\textbf{Operacion} & \textbf{Complejidad} & \textbf{Justificacion} \\
			\hline
			Inicializar juego & O(n) & Crear y mezclar 52 cartas \\
			Dibujar carta & O(1) & Operaciones graficas constantes \\
			Validar movimiento & O(1) & Comparaciones simples \\
			Redibujar todo & O(n) & n cartas visibles \\
			Detectar colision & O(1) & Calculos aritmeticos simples \\
			\hline
		\end{tabular}
		\caption{Analisis de complejidad temporal}
	\end{table}
	
	\subsection{Complejidad Espacial}
	
	\begin{itemize}
		\item \textbf{Cartas}: O(52) = O(1) - tamanio fijo
		\item \textbf{Widgets graficos}: O(n) donde n menor o igual a 52
		\item \textbf{Pilas de juego}: O(1) - estructuras fijas
		\item \textbf{Total}: O(1) - espacio constante
	\end{itemize}
	
	\section{Pruebas y Validacion}
	
	\subsection{Casos de Prueba}
	
	\subsubsection{Prueba 1: Inicializacion del Juego}
	
	\textbf{Objetivo}: Verificar que el juego se inicializa correctamente.
	
	\textbf{Procedimiento}:
	\begin{enumerate}
		\item Ejecutar el programa
		\item Observar la distribucion inicial de cartas
		\item Verificar que hay 7 columnas en el tableau
		\item Confirmar que la ultima carta de cada columna esta boca arriba
	\end{enumerate}
	
	\textbf{Resultado esperado}: 28 cartas distribuidas, 24 en mazo.
	
	\subsubsection{Prueba 2: Movimientos Validos}
	
	\textbf{Objetivo}: Validar la logica de movimientos permitidos.
	
	\textbf{Casos}:
	\begin{itemize}
		\item Mover carta negra sobre carta roja de valor superior
		\item Intentar mover carta del mismo color (debe rechazarse)
		\item Colocar Rey en espacio vacio
		\item Mover As a fundacion vacia
	\end{itemize}
	
	\subsubsection{Prueba 3: Condicion de Victoria}
	
	\textbf{Objetivo}: Verificar deteccion de victoria.
	
	\textbf{Procedimiento}:
	\begin{enumerate}
		\item Manipular el juego hasta completar las 4 fundaciones
		\item Verificar aparicion del mensaje de victoria
		\item Confirmar que se muestra el numero de movimientos
	\end{enumerate}
	
	\subsection{Resultados de Pruebas}
	
	\begin{table}[h]
		\centering
		\begin{tabular}{|l|c|l|}
			\hline
			\textbf{Caso de Prueba} & \textbf{Estado} & \textbf{Observaciones} \\
			\hline
			Inicializacion & Paso & Distribucion correcta \\
			Movimientos validos & Paso & Validacion funcional \\
			Movimientos invalidos & Paso & Rechazos apropiados \\
			Drag and Drop & Paso & Fluido y preciso \\
			Condicion de victoria & Paso & Deteccion correcta \\
			Reinicio de juego & Paso & Estado limpio \\
			\hline
		\end{tabular}
		\caption{Resultados de pruebas funcionales}
	\end{table}
	
	\section{Aplicacion de Conceptos de la Unidad 4}
	
	\subsection{Estructuras de Datos}
	
	El proyecto hace uso extensivo de estructuras de datos de Python:
	
	\begin{description}
		\item[Listas] Para representar pilas de cartas
		\item[Diccionarios] Para configuracion y estado temporal
		\item[Tuplas] Para retornos multiples inmutables
	\end{description}
	
	\subsection{Algoritmos Implementados}
	
	\subsubsection{Algoritmo de Mezcla}
	
	Utiliza el algoritmo Fisher-Yates implementado en random.shuffle():
	
	\begin{lstlisting}
		self.deck = [Card(suit, rank) for suit in SUITS 
		for rank in RANKS]
		random.shuffle(self.deck)
	\end{lstlisting}
	
	Complejidad: O(n) donde n = 52
	
	\subsubsection{Algoritmo de Busqueda}
	
	Para detectar clics, se utiliza busqueda lineal:
	
	\begin{lstlisting}
		def is_click_on_tableau(self, x, y):
		for i, pile in enumerate(self.tableau):
		for j, card in enumerate(pile):
		if is_inside(x, y, card_bounds):
		return i, j
	\end{lstlisting}
	
	Complejidad: O(7 por m) donde m es el promedio de cartas por columna.
	
	\subsection{Programacion Orientada a Objetos}
	
	\subsubsection{Encapsulamiento}
	
	Cada clase encapsula su propia logica:
	
	\begin{itemize}
		\item Card: Datos y operaciones de una carta
		\item CardWidget: Renderizado visual
		\item SolitaireGame: Logica del juego
	\end{itemize}
	
	\subsubsection{Abstraccion}
	
	Los metodos publicos ocultan detalles de implementacion:
	
	\begin{lstlisting}
		# Interfaz simple
		game.draw_from_deck()
		
		# Implementacion interna compleja
		def draw_from_deck(self):
		if self.deck:
		card = self.deck.pop()
		card.face_up = True
		self.waste.append(card)
		self.increment_moves()
	\end{lstlisting}
	
	\subsubsection{Composicion}
	
	SolitaireGame compone multiples CardWidget:
	
	\begin{lstlisting}
		self.card_widgets = []
		
		for card in visible_cards:
		widget = CardWidget(self.canvas, card, x, y)
		self.card_widgets.append(widget)
	\end{lstlisting}
	
	\section{Mejoras Futuras}
	
	\subsection{Funcionalidades Adicionales}
	
	\begin{enumerate}
		\item Sistema de Pistas: Resaltar movimientos posibles
		\item Deshacer/Rehacer: Stack de estados anteriores
		\item Estadisticas: Guardar records y porcentaje de victorias
		\item Diferentes Variantes: Spider, FreeCell, etc.
		\item Modo Tutorial: Guia para nuevos jugadores
	\end{enumerate}
	
	\subsection{Optimizaciones Tecnicas}
	
	\begin{enumerate}
		\item Renderizado Selectivo: Solo redibujar elementos modificados
		\item Doble Clic Automatico: Mover automaticamente a fundaciones
		\item Animaciones Suavizadas: Usar interpolacion cuadratica
		\item Resolucion Adaptativa: Ajustar tamanio segun ventana
	\end{enumerate}
	
	\subsection{Arquitectura}
	
	\begin{enumerate}
		\item Patron MVC: Separar modelo, vista y controlador
		\item Sistema de Eventos: Implementar observer pattern
		\item Persistencia: Guardar y cargar estado del juego
		\item Testing: Suite de pruebas unitarias con pytest
	\end{enumerate}
	
	\section{Conclusiones}
	
	\subsection{Logros del Proyecto}
	
	El proyecto cumplio exitosamente con todos los objetivos planteados:
	
	\begin{itemize}
		\item Implementacion completa de un juego de mesa funcional
		\item Interfaz grafica atractiva y responsiva
		\item Aplicacion correcta de principios de POO
		\item Manejo eficiente de estructuras de datos
		\item Sistema de eventos robusto
	\end{itemize}
	
	\subsection{Aprendizajes Clave}
	
	Durante el desarrollo se obtuvieron aprendizajes valiosos:
	
	\begin{enumerate}
		\item Diseno de Software: La importancia de planificar la arquitectura
		\item Gestion de Estado: Mantener sincronizacion entre modelo y vista
		\item Debugging Visual: Tecnicas para depurar interfaces graficas
		\item Manejo de Eventos: Complejidad de sistemas interactivos
	\end{enumerate}
	
	\subsection{Aplicacion Practica}
	
	Este proyecto demuestra competencias en:
	
	\begin{itemize}
		\item Programacion Orientada a Objetos
		\item Estructuras de datos complejas
		\item Desarrollo de interfaces graficas
		\item Algoritmos de validacion
		\item Gestion de eventos de usuario
	\end{itemize}
	
	\subsection{Reflexion Final}
	
	La implementacion del Solitario Klondike representa un desafio completo que integra multiples areas de la programacion. Este proyecto demuestra la capacidad de:
	
	\begin{itemize}
		\item Analizar un problema complejo
		\item Disenar una solucion escalable
		\item Implementar codigo mantenible
		\item Crear experiencias de usuario agradables
	\end{itemize}
	
	El codigo resultante es extensible, permitiendo agregar facilmente nuevas caracteristicas o variantes del juego.
	
	\section{Referencias}
	
	\begin{enumerate}
		\item Python Software Foundation. (2024). Python Documentation. https://docs.python.org/3/
		
		\item Tkinter Documentation. (2024). Tk Commands. https://docs.python.org/3/library/tkinter.html
		
		\item Gamma, E. y otros (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley.
		
		\item Lutz, M. (2013). Learning Python, 5th Edition. O'Reilly Media.
		
		\item Wikipedia Contributors. (2024). Klondike solitaire. Wikipedia.
		
		\item Python.org. (2024). Python Type Hints. https://docs.python.org/3/library/typing.html
		
		\item Real Python. (2024). Python GUI Programming With Tkinter.
	\end{enumerate}
	
	\appendix
	
	\section{Codigo Completo}
	
	El codigo completo del proyecto esta disponible en el archivo solitaire\_klondike.py.
	
	\subsection{Estructura de Archivos}
	
	El proyecto consta de los siguientes archivos:
	
	\begin{itemize}
		\item solitaire\_klondike.py - Codigo principal
		\item informe.tex - Este documento
		\item informe.pdf - Documento compilado
		\item README.md - Instrucciones de ejecucion
	\end{itemize}
	
	\subsection{Requisitos del Sistema}
	
	\begin{itemize}
		\item Python 3.8 o superior
		\item Tkinter incluido en instalacion estandar de Python
		\item Sistema operativo: Windows, macOS, o Linux
		\item Resolucion minima: 800x650 pixeles
	\end{itemize}
	
	\subsection{Instrucciones de Ejecucion}
	
	Para ejecutar el juego:
	
	\begin{verbatim}
		cd proyecto_solitario
		python solitaire_klondike.py
	\end{verbatim}
	
	Para compilar el informe LaTeX:
	
	\begin{verbatim}
		pdflatex informe.tex
		pdflatex informe.tex
	\end{verbatim}
	
	\section{Glosario de Terminos}
	
	\begin{description}
		\item[Canvas] Area de dibujo en Tkinter donde se renderizan elementos graficos
		\item[Dataclass] Decorador de Python para crear clases con menos codigo
		\item[Drag and Drop] Tecnica de interaccion donde se arrastra y suelta un elemento
		\item[Event Handler] Funcion que responde a eventos del usuario
		\item[Foundation] Pila objetivo donde se construyen secuencias As-Rey
		\item[Framework] Conjunto de herramientas y bibliotecas para facilitar desarrollo
		\item[GUI] Interfaz Grafica de Usuario
		\item[Tableau] Area principal de juego con 7 columnas de cartas
		\item[Widget] Componente visual reutilizable de una interfaz grafica
		\item[Waste] Pila de descarte para cartas robadas del mazo
	\end{description}
	
\end{document}